<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EMDR Tool with Binaural Tactile Sounds</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; background: #f4f4f4; color:#111; }
  h1 { margin-top: 18px; }
  .controls { margin: 14px auto; max-width: 820px; }
  .row { display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap; }
  label { font-size: 14px; }
  canvas { background: white; display: block; margin: 18px auto; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
  button { padding: 8px 14px; font-size: 14px; cursor: pointer; }
  .small { font-size: 13px; color: #333; }
  input[type="range"] { vertical-align: middle; }
  select { vertical-align: middle; padding: 2px 6px; }
</style>
</head>
<body>
  <h1>EMDR Tool</h1>

  <div class="controls">
    <div class="row">
      <label>Speed:
        <input id="speedSlider" type="range" min="0.5" max="12" step="0.1" value="2" />
      </label>
      <span class="small"><strong id="speedDisplay">2.0</strong> px/frame</span>

      <label>Cycles (per set):
        <input id="cycles" type="number" min="1" value="5" style="width:70px" />
      </label>

      <label>Sets done: <span id="sets">0</span></label>

      <label>Colour:
        <input id="color" type="color" value="#ff0000" />
      </label>

      <label>Shape:
        <select id="shape">
          <option value="circle">Circle</option>
          <option value="bar">Bar</option>
          <option value="diamond">Diamond</option>
          <option value="star">Star</option>
          <option value="cat">Cat Face</option>
        </select>
      </label>

      <label>Sound:
        <select id="soundSelect">
          <option value="ding">Soft Ding</option>
          <option value="knock">Wooden Knock</option>
          <option value="chime">Calm Chime</option>
          <option value="tap">Muted Tap</option>
        </select>
      </label>

      <label>Tactile:
        <input id="tactile" type="checkbox" />
      </label>

      <button id="startBtn">Start</button>
    </div>
  </div>

  <canvas id="emdrCanvas" width="800" height="220"></canvas>

<script>
const canvas = document.getElementById('emdrCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const speedSlider = document.getElementById('speedSlider');
const speedDisplay = document.getElementById('speedDisplay');
const cyclesInput = document.getElementById('cycles');
const setsDisplay = document.getElementById('sets');
const colorInput = document.getElementById('color');
const shapeInput = document.getElementById('shape');
const tactileToggle = document.getElementById('tactile');
const soundSelect = document.getElementById('soundSelect');

let audioCtx = null;

// Minimal tone generator (sine wave) for 4 sounds with different frequencies
function createToneBuffer(freq, duration = 0.12) {
  const sampleRate = 44100;
  const length = sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0; i<length; i++) {
    data[i] = Math.sin(2 * Math.PI * freq * i / sampleRate) * Math.exp(-3 * i / length);
  }
  return buffer;
}

const toneFrequencies = {
  ding: 880,
  knock: 440,
  chime: 660,
  tap: 550
};

let audioBuffers = {};

async function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  for (const [key, freq] of Object.entries(toneFrequencies)) {
    audioBuffers[key] = createToneBuffer(freq);
  }
}

async function playSound(soundKey, pan) {
  if (!audioCtx) await initAudio();

  const buffer = audioBuffers[soundKey];
  if (!buffer) return;

  const source = audioCtx.createBufferSource();
  source.buffer = buffer;

  const panner = audioCtx.createStereoPanner();
  panner.pan.value = pan;

  source.connect(panner).connect(audioCtx.destination);
  source.start(0);
}

let x = 0;
let dir = 1;
let animating = false;
let animationId = null;

let cyclesCompleted = 0;
let sets = 0;
let totalCycles = parseInt(cyclesInput.value, 10) || 1;

let reachedRight = false;
let countedThisReturn = false;

let playedRight = false;
let playedLeft = false;

function halfWidthForShape(shape) {
  if (shape === 'bar') return 30;
  return 15;
}

function drawShape(shape, cx, cy, color) {
  ctx.fillStyle = color;
  ctx.strokeStyle = color;

  if (shape === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, 15, 0, Math.PI * 2);
    ctx.fill();
  } else if (shape === 'bar') {
    ctx.fillRect(cx - 30, cy - 12, 60, 24);
  } else if (shape === 'diamond') {
    ctx.beginPath();
    ctx.moveTo(cx, cy - 15);
    ctx.lineTo(cx + 15, cy);
    ctx.lineTo(cx, cy + 15);
    ctx.lineTo(cx - 15, cy);
    ctx.closePath();
    ctx.fill();
  } else if (shape === 'star') {
    const spikes = 5;
    const outer = 15;
    const inner = 7;
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outer);
    for (let i = 0; i < spikes; i++) {
      ctx.lineTo(cx + Math.cos(rot) * outer, cy + Math.sin(rot) * outer);
      rot += step;
      ctx.lineTo(cx + Math.cos(rot) * inner, cy + Math.sin(rot) * inner);
      rot += step;
    }
    ctx.closePath();
    ctx.fill();
  } else if (shape === 'cat') {
    ctx.beginPath();
    ctx.arc(cx, cy, 15, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(cx - 9, cy - 12);
    ctx.lineTo(cx - 16, cy - 26);
    ctx.lineTo(cx - 2, cy - 15);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(cx + 9, cy - 12);
    ctx.lineTo(cx + 16, cy - 26);
    ctx.lineTo(cx + 2, cy - 15);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(cx - 5, cy - 3, 2.2, 0, Math.PI * 2);
    ctx.arc(cx + 5, cy - 3, 2.2, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(cx, cy - 1);
    ctx.lineTo(cx, cy + 3);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1.1;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cx - 12, cy + 3);
    ctx.lineTo(cx - 22, cy + 3);
    ctx.moveTo(cx - 12, cy + 6);
    ctx.lineTo(cx - 22, cy + 6);
    ctx.moveTo(cx + 12, cy + 3);
    ctx.lineTo(cx + 22, cy + 3);
    ctx.moveTo(cx + 12, cy + 6);
    ctx.lineTo(cx + 22, cy + 6);
    ctx.stroke();
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const shape = shapeInput.value;
  const halfW = halfWidthForShape(shape);
  const leftBound = halfW;
  const rightBound = canvas.width - halfW;
  const centerX = canvas.width / 2;

  drawShape(shape, x, canvas.height / 2, colorInput.value);

  const speed = parseFloat(speedSlider.value);
  x += dir * speed;

  if (x >= rightBound) {
    x = rightBound;
    dir = -1;
    reachedRight = true;
    countedThisReturn = false;

    if (tactileToggle.checked && !playedRight) {
      playSound(soundSelect.value, 1); // pan right
      playedRight = true;
    }
  } else {
    playedRight = false;
  }

  const tol = Math.max(2, speed * 1.5);
  if (dir < 0 && reachedRight && !countedThisReturn && x <= centerX + tol) {
    cyclesCompleted++;
    countedThisReturn = true;

    if (tactileToggle.checked) {
      playSound(soundSelect.value, 0); // center pan for cycle (optional)
    }

    if (cyclesCompleted >= totalCycles) {
      sets++;
      setsDisplay.textContent = sets;
      cyclesCompleted = 0;
    }
  }

  if (x <= leftBound) {
    x = leftBound;
    dir = 1;
    reachedRight = false;
    countedThisReturn = false;

    if (tactileToggle.checked && !playedLeft) {
      playSound(soundSelect.value, -1); // pan left
      playedLeft = true;
    }
  } else {
    playedLeft = false;
  }

  animationId = requestAnimationFrame(animate);
}

function startAnimation() {
  if (animating) return;
  totalCycles = parseInt(cyclesInput.value, 10) || 1;
  cyclesCompleted = 0;
  const halfW = halfWidthForShape(shapeInput.value);
  x = halfW;
  dir = 1;
  reachedRight = false;
  countedThisReturn = false;
  playedRight = false;
  playedLeft = false;

  animating = true;
  startBtn.textContent = "Stop";
  speedDisplay.textContent = parseFloat(speedSlider.value).toFixed(1);
  animate();
}

function stopAnimation() {
  if (!animating) return;
  cancelAnimationFrame(animationId);
  animating = false;
  startBtn.textContent = "Start";
}

startBtn.addEventListener("click", () => {
  if (!animating) startAnimation();
  else stopAnimation();
});

speedSlider.addEventListener("input", () => {
  speedDisplay.textContent = parseFloat(speedSlider.value).toFixed(1);
});
</script>
</body>
</html>
